{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { w3cwebsocket } from 'websocket';\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS, CONNECTION_STATE } from './lib/constants';\nimport Timer from './lib/timer';\nimport Serializer from './lib/serializer';\nimport RealtimeChannel from './RealtimeChannel';\nvar noop = function noop() {};\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n    _classCallCheck(this, RealtimeClient);\n    var _a;\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = w3cwebsocket;\n    this.heartbeatIntervalMs = 30000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.eventsPerSecondLimitMs = 100;\n    this.inThrottle = false;\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    var eventsPerSecond = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.eventsPerSecond;\n    if (eventsPerSecond) this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond);\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              this.disconnect();\n              this.connect();\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket, unless already connected.\n   */\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n      if (this.conn) {\n        return;\n      }\n      this.conn = new this.transport(this._endPointURL(), [], null, this.headers);\n      if (this.conn) {\n        this.conn.binaryType = 'arraybuffer';\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n        this.conn.onmessage = function (event) {\n          return _this2._onConnMessage(event);\n        };\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      if (this.conn) {\n        this.conn.onclose = function () {}; // noop\n        if (code) {\n          this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');\n        } else {\n          this.conn.close();\n        }\n        this.conn = null;\n        // remove open handles\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.reconnectTimer.reset();\n      }\n    }\n    /**\n     * Returns all created channels\n     */\n  }, {\n    key: \"getChannels\",\n    value: function getChannels() {\n      return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */\n  }, {\n    key: \"removeChannel\",\n    value: function removeChannel(channel) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var status;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return channel.unsubscribe();\n            case 2:\n              status = _context2.sent;\n              if (this.channels.length === 0) {\n                this.disconnect();\n              }\n              return _context2.abrupt(\"return\", status);\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */\n  }, {\n    key: \"removeAllChannels\",\n    value: function removeAllChannels() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var values_1;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return Promise.all(this.channels.map(function (channel) {\n                return channel.unsubscribe();\n              }));\n            case 2:\n              values_1 = _context3.sent;\n              this.disconnect();\n              return _context3.abrupt(\"return\", values_1);\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return CONNECTION_STATE.Connecting;\n        case SOCKET_STATES.open:\n          return CONNECTION_STATE.Open;\n        case SOCKET_STATES.closing:\n          return CONNECTION_STATE.Closing;\n        default:\n          return CONNECTION_STATE.Closed;\n      }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === CONNECTION_STATE.Open;\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        config: {}\n      };\n      if (!this.isConnected()) {\n        this.connect();\n      }\n      var chan = new RealtimeChannel(\"realtime:\".concat(topic), params, this);\n      this.channels.push(chan);\n      return chan;\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this3 = this;\n      var topic = data.topic,\n        event = data.event,\n        payload = data.payload,\n        ref = data.ref;\n      var callback = function callback() {\n        _this3.encode(data, function (result) {\n          var _a;\n          (_a = _this3.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n      if (this.isConnected()) {\n        if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n          var isThrottled = this._throttle(callback)();\n          if (isThrottled) {\n            return 'rate limited';\n          }\n        } else {\n          callback();\n        }\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n      this.channels.forEach(function (channel) {\n        token && channel.updateJoinPayload({\n          access_token: token\n        });\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: token\n          });\n        }\n      });\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */\n  }, {\n    key: \"_makeRef\",\n    value: function _makeRef() {\n      var newRef = this.ref + 1;\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n      return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_leaveOpenTopic\",\n    value: function _leaveOpenTopic(topic) {\n      var dupChannel = this.channels.find(function (c) {\n        return c.topic === topic && (c._isJoined() || c._isJoining());\n      });\n      if (dupChannel) {\n        this.log('transport', \"leaving duplicate topic \\\"\".concat(topic, \"\\\"\"));\n        dupChannel.unsubscribe();\n      }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_remove\",\n    value: function _remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c._joinRef() !== channel._joinRef();\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     *\n     * @internal\n     */\n  }, {\n    key: \"_endPointURL\",\n    value: function _endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnMessage\",\n    value: function _onConnMessage(rawMessage) {\n      var _this4 = this;\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n          event = msg.event,\n          payload = msg.payload,\n          ref = msg.ref;\n        if (ref && ref === _this4.pendingHeartbeatRef || event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this4.pendingHeartbeatRef = null;\n        }\n        _this4.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n        _this4.channels.filter(function (channel) {\n          return channel._isMember(topic);\n        }).forEach(function (channel) {\n          return channel._trigger(event, payload, ref);\n        });\n        _this4.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      var _this5 = this;\n      this.log('transport', \"connected to \".concat(this._endPointURL()));\n      this._flushSendBuffer();\n      this.reconnectTimer.reset();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this5._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n      this._triggerChanError();\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n      this._triggerChanError();\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel._trigger(CHANNEL_EVENTS.error);\n      });\n    }\n    /** @internal */\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n    /** @internal */\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n    /** @internal */\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n      if (!this.isConnected()) {\n        return;\n      }\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n      this.pendingHeartbeatRef = this._makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n    /** @internal */\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(callback) {\n      var _this6 = this;\n      var eventsPerSecondLimitMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.eventsPerSecondLimitMs;\n      return function () {\n        if (_this6.inThrottle) return true;\n        callback();\n        if (eventsPerSecondLimitMs > 0) {\n          _this6.inThrottle = true;\n          setTimeout(function () {\n            _this6.inThrottle = false;\n          }, eventsPerSecondLimitMs);\n        }\n        return false;\n      };\n    }\n  }]);\n  return RealtimeClient;\n}();\nexport { RealtimeClient as default };","map":{"version":3,"names":["w3cwebsocket","VSN","CHANNEL_EVENTS","TRANSPORTS","SOCKET_STATES","DEFAULT_TIMEOUT","WS_CLOSE_NORMAL","DEFAULT_HEADERS","CONNECTION_STATE","Timer","Serializer","RealtimeChannel","noop","RealtimeClient","endPoint","options","_this","_classCallCheck","accessToken","channels","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","ref","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","eventsPerSecondLimitMs","inThrottle","concat","websocket","Object","assign","eventsPerSecond","_a","Math","floor","reconnectAfterMs","tries","encode","payload","callback","JSON","stringify","decode","bind","reconnectTimer","__awaiter","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","disconnect","connect","stop","_createClass","key","value","_this2","_endPointURL","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","event","_onConnMessage","onclose","_onConnClose","code","reason","clearInterval","reset","getChannels","removeChannel","channel","unsubscribe","status","_context2","sent","length","abrupt","_callee2","removeAllChannels","Promise","all","map","values_1","_context3","_callee3","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","isConnected","topic","arguments","config","chan","push","_this3","result","send","includes","isThrottled","_throttle","setAuth","token","forEach","updateJoinPayload","access_token","joinedOnce","_isJoined","_push","_makeRef","newRef","toString","_leaveOpenTopic","dupChannel","find","c","_isJoining","_remove","filter","_joinRef","_appendParams","vsn","rawMessage","_this4","type","_isMember","_trigger","_this5","_flushSendBuffer","setInterval","_sendHeartbeat","_triggerChanError","scheduleTimeout","url","keys","prefix","match","query","URLSearchParams","_this6","setTimeout","default"],"sources":["C:\\Users\\deradoi\\udemy\\Crash Course - Build a Full Stack Web App\\today-i-learned\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"sourcesContent":["import { w3cwebsocket } from 'websocket'\nimport {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n  CONNECTION_STATE,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport Serializer from './lib/serializer'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n}\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeChannel[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = w3cwebsocket\n  heartbeatIntervalMs: number = 30000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  eventsPerSecondLimitMs: number = 100\n  inThrottle: boolean = false\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n\n    const eventsPerSecond = options?.params?.eventsPerSecond\n    if (eventsPerSecond)\n      this.eventsPerSecondLimitMs = Math.floor(1000 / eventsPerSecond)\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this._endPointURL(), [], null, this.headers)\n\n    if (this.conn) {\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error as ErrorEvent)\n      this.conn.onmessage = (event) => this._onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.conn) {\n      this.conn.onclose = function () {} // noop\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n      this.conn = null\n      // remove open handles\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n      this.reconnectTimer.reset()\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    if (!this.isConnected()) {\n      this.connect()\n    }\n\n    const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): 'rate limited' | void {\n    const { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      if (['broadcast', 'presence', 'postgres_changes'].includes(event)) {\n        const isThrottled = this._throttle(callback)()\n        if (isThrottled) {\n          return 'rate limited'\n        }\n      } else {\n        callback()\n      }\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null): void {\n    this.accessToken = token\n\n    this.channels.forEach((channel) => {\n      token && channel.updateJoinPayload({ access_token: token })\n\n      if (channel.joinedOnce && channel._isJoined()) {\n        channel._push(CHANNEL_EVENTS.access_token, { access_token: token })\n      }\n    })\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter(\n      (c: RealtimeChannel) => c._joinRef() !== channel._joinRef()\n    )\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   *\n   * @internal\n   */\n  private _endPointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      let { topic, event, payload, ref } = msg\n\n      if (\n        (ref && ref === this.pendingHeartbeatRef) ||\n        event === payload?.type\n      ) {\n        this.pendingHeartbeatRef = null\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this._endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  /** @internal */\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  /** @internal */\n  private _onConnError(error: ErrorEvent) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  /** @internal */\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n  /** @internal */\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n\n  /** @internal */\n  private _throttle(\n    callback: Function,\n    eventsPerSecondLimitMs: number = this.eventsPerSecondLimitMs\n  ): () => boolean {\n    return () => {\n      if (this.inThrottle) return true\n\n      callback()\n\n      if (eventsPerSecondLimitMs > 0) {\n        this.inThrottle = true\n\n        setTimeout(() => {\n          this.inThrottle = false\n        }, eventsPerSecondLimitMs)\n      }\n\n      return false\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}