{"ast":null,"code":"import _slicedToArray from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder';\nvar PostgrestFilterBuilder = /*#__PURE__*/function (_PostgrestTransformBu) {\n  _inherits(PostgrestFilterBuilder, _PostgrestTransformBu);\n  var _super = _createSuper(PostgrestFilterBuilder);\n  function PostgrestFilterBuilder() {\n    _classCallCheck(this, PostgrestFilterBuilder);\n    return _super.apply(this, arguments);\n  }\n  _createClass(PostgrestFilterBuilder, [{\n    key: \"eq\",\n    value:\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n    function eq(column, value) {\n      this.url.searchParams.append(column, \"eq.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"neq\",\n    value: function neq(column, value) {\n      this.url.searchParams.append(column, \"neq.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"gt\",\n    value: function gt(column, value) {\n      this.url.searchParams.append(column, \"gt.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"gte\",\n    value: function gte(column, value) {\n      this.url.searchParams.append(column, \"gte.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"lt\",\n    value: function lt(column, value) {\n      this.url.searchParams.append(column, \"lt.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"lte\",\n    value: function lte(column, value) {\n      this.url.searchParams.append(column, \"lte.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n  }, {\n    key: \"like\",\n    value: function like(column, pattern) {\n      this.url.searchParams.append(column, \"like.\".concat(pattern));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"likeAllOf\",\n    value: function likeAllOf(column, patterns) {\n      this.url.searchParams.append(column, \"like(all).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"likeAnyOf\",\n    value: function likeAnyOf(column, patterns) {\n      this.url.searchParams.append(column, \"like(any).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */\n  }, {\n    key: \"ilike\",\n    value: function ilike(column, pattern) {\n      this.url.searchParams.append(column, \"ilike.\".concat(pattern));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"ilikeAllOf\",\n    value: function ilikeAllOf(column, patterns) {\n      this.url.searchParams.append(column, \"ilike(all).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */\n  }, {\n    key: \"ilikeAnyOf\",\n    value: function ilikeAnyOf(column, patterns) {\n      this.url.searchParams.append(column, \"ilike(any).{\".concat(patterns.join(','), \"}\"));\n      return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */\n  }, {\n    key: \"is\",\n    value: function is(column, value) {\n      this.url.searchParams.append(column, \"is.\".concat(value));\n      return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */\n  }, {\n    key: \"in\",\n    value: function _in(column, values) {\n      var cleanedValues = values.map(function (s) {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return \"\\\"\".concat(s, \"\\\"\");else return \"\".concat(s);\n      }).join(',');\n      this.url.searchParams.append(column, \"in.(\".concat(cleanedValues, \")\"));\n      return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n  }, {\n    key: \"contains\",\n    value: function contains(column, value) {\n      if (typeof value === 'string') {\n        // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n        // keep it simple and accept a string\n        this.url.searchParams.append(column, \"cs.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cs.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cs.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */\n  }, {\n    key: \"containedBy\",\n    value: function containedBy(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"cd.\".concat(value));\n      } else if (Array.isArray(value)) {\n        // array\n        this.url.searchParams.append(column, \"cd.{\".concat(value.join(','), \"}\"));\n      } else {\n        // json\n        this.url.searchParams.append(column, \"cd.\".concat(JSON.stringify(value)));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeGt\",\n    value: function rangeGt(column, range) {\n      this.url.searchParams.append(column, \"sr.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeGte\",\n    value: function rangeGte(column, range) {\n      this.url.searchParams.append(column, \"nxl.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeLt\",\n    value: function rangeLt(column, range) {\n      this.url.searchParams.append(column, \"sl.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeLte\",\n    value: function rangeLte(column, range) {\n      this.url.searchParams.append(column, \"nxr.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */\n  }, {\n    key: \"rangeAdjacent\",\n    value: function rangeAdjacent(column, range) {\n      this.url.searchParams.append(column, \"adj.\".concat(range));\n      return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */\n  }, {\n    key: \"overlaps\",\n    value: function overlaps(column, value) {\n      if (typeof value === 'string') {\n        // range\n        this.url.searchParams.append(column, \"ov.\".concat(value));\n      } else {\n        // array\n        this.url.searchParams.append(column, \"ov.{\".concat(value.join(','), \"}\"));\n      }\n      return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */\n  }, {\n    key: \"textSearch\",\n    value: function textSearch(column, query) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        config = _ref.config,\n        type = _ref.type;\n      var typePart = '';\n      if (type === 'plain') {\n        typePart = 'pl';\n      } else if (type === 'phrase') {\n        typePart = 'ph';\n      } else if (type === 'websearch') {\n        typePart = 'w';\n      }\n      var configPart = config === undefined ? '' : \"(\".concat(config, \")\");\n      this.url.searchParams.append(column, \"\".concat(typePart, \"fts\").concat(configPart, \".\").concat(query));\n      return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */\n  }, {\n    key: \"match\",\n    value: function match(query) {\n      var _this = this;\n      Object.entries(query).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n          column = _ref3[0],\n          value = _ref3[1];\n        _this.url.searchParams.append(column, \"eq.\".concat(value));\n      });\n      return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n  }, {\n    key: \"not\",\n    value: function not(column, operator, value) {\n      this.url.searchParams.append(column, \"not.\".concat(operator, \".\").concat(value));\n      return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param foreignTable - Set this to filter on foreign tables instead of the\n     * current table\n     */\n  }, {\n    key: \"or\",\n    value: function or(filters) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        foreignTable = _ref4.foreignTable;\n      var key = foreignTable ? \"\".concat(foreignTable, \".or\") : 'or';\n      this.url.searchParams.append(key, \"(\".concat(filters, \")\"));\n      return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */\n  }, {\n    key: \"filter\",\n    value: function filter(column, operator, value) {\n      this.url.searchParams.append(column, \"\".concat(operator, \".\").concat(value));\n      return this;\n    }\n  }]);\n  return PostgrestFilterBuilder;\n}(PostgrestTransformBuilder);\nexport { PostgrestFilterBuilder as default };","map":{"version":3,"names":["PostgrestTransformBuilder","PostgrestFilterBuilder","_PostgrestTransformBu","_inherits","_super","_createSuper","_classCallCheck","apply","arguments","_createClass","key","value","eq","column","url","searchParams","append","concat","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","join","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","_in","values","cleanedValues","map","s","RegExp","test","contains","Array","isArray","JSON","stringify","containedBy","rangeGt","range","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","_ref","length","undefined","config","type","typePart","configPart","match","_this","Object","entries","forEach","_ref2","_ref3","_slicedToArray","not","operator","or","filters","_ref4","foreignTable","filter","default"],"sources":["C:\\Users\\deradoi\\udemy\\Crash Course - Build a Full Stack Web App\\today-i-learned\\node_modules\\@supabase\\postgrest-js\\src\\PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result\n> extends PostgrestTransformBuilder<Schema, Row, Result> {\n  eq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  eq(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  neq<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  neq(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  likeAllOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  likeAnyOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  ilikeAllOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(column: ColumnName, patterns: string[]): this\n  ilikeAnyOf(column: string, patterns: string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  in<ColumnName extends string & keyof Row>(column: ColumnName, values: Row[ColumnName][]): this\n  in(column: string, values: unknown[]): this\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in(column: string, values: unknown[]): this {\n    const cleanedValues = values\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][] | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | Row[ColumnName][]\n  ): this\n  overlaps(column: string, value: string | unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param foreignTable - Set this to filter on foreign tables instead of the\n   * current table\n   */\n  or(filters: string, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = foreignTable ? `${foreignTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}