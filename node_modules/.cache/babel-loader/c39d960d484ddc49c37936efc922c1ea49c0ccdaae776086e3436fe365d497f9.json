{"ast":null,"code":"import _classCallCheck from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/deradoi/udemy/Crash Course - Build a Full Stack Web App/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { DEFAULT_TIMEOUT } from '../lib/constants';\nvar Push = /*#__PURE__*/function () {\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  function Push(channel, event) {\n    var payload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_TIMEOUT;\n    _classCallCheck(this, Push);\n    this.channel = channel;\n    this.event = event;\n    this.payload = payload;\n    this.timeout = timeout;\n    this.sent = false;\n    this.timeoutTimer = undefined;\n    this.ref = '';\n    this.receivedResp = null;\n    this.recHooks = [];\n    this.refEvent = null;\n    this.rateLimited = false;\n  }\n  _createClass(Push, [{\n    key: \"resend\",\n    value: function resend(timeout) {\n      this.timeout = timeout;\n      this._cancelRefEvent();\n      this.ref = '';\n      this.refEvent = null;\n      this.receivedResp = null;\n      this.sent = false;\n      this.send();\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      if (this._hasReceived('timeout')) {\n        return;\n      }\n      this.startTimeout();\n      this.sent = true;\n      var status = this.channel.socket.push({\n        topic: this.channel.topic,\n        event: this.event,\n        payload: this.payload,\n        ref: this.ref,\n        join_ref: this.channel._joinRef()\n      });\n      if (status === 'rate limited') {\n        this.rateLimited = true;\n      }\n    }\n  }, {\n    key: \"updatePayload\",\n    value: function updatePayload(payload) {\n      this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n  }, {\n    key: \"receive\",\n    value: function receive(status, callback) {\n      var _a;\n      if (this._hasReceived(status)) {\n        callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n      }\n      this.recHooks.push({\n        status: status,\n        callback: callback\n      });\n      return this;\n    }\n  }, {\n    key: \"startTimeout\",\n    value: function startTimeout() {\n      var _this = this;\n      if (this.timeoutTimer) {\n        return;\n      }\n      this.ref = this.channel.socket._makeRef();\n      this.refEvent = this.channel._replyEventName(this.ref);\n      var callback = function callback(payload) {\n        _this._cancelRefEvent();\n        _this._cancelTimeout();\n        _this.receivedResp = payload;\n        _this._matchReceive(payload);\n      };\n      this.channel._on(this.refEvent, {}, callback);\n      this.timeoutTimer = setTimeout(function () {\n        _this.trigger('timeout', {});\n      }, this.timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(status, response) {\n      if (this.refEvent) this.channel._trigger(this.refEvent, {\n        status: status,\n        response: response\n      });\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._cancelRefEvent();\n      this._cancelTimeout();\n    }\n  }, {\n    key: \"_cancelRefEvent\",\n    value: function _cancelRefEvent() {\n      if (!this.refEvent) {\n        return;\n      }\n      this.channel._off(this.refEvent, {});\n    }\n  }, {\n    key: \"_cancelTimeout\",\n    value: function _cancelTimeout() {\n      clearTimeout(this.timeoutTimer);\n      this.timeoutTimer = undefined;\n    }\n  }, {\n    key: \"_matchReceive\",\n    value: function _matchReceive(_ref) {\n      var status = _ref.status,\n        response = _ref.response;\n      this.recHooks.filter(function (h) {\n        return h.status === status;\n      }).forEach(function (h) {\n        return h.callback(response);\n      });\n    }\n  }, {\n    key: \"_hasReceived\",\n    value: function _hasReceived(status) {\n      return this.receivedResp && this.receivedResp.status === status;\n    }\n  }]);\n  return Push;\n}();\nexport { Push as default };","map":{"version":3,"names":["DEFAULT_TIMEOUT","Push","channel","event","payload","arguments","length","undefined","timeout","_classCallCheck","sent","timeoutTimer","ref","receivedResp","recHooks","refEvent","rateLimited","_createClass","key","value","resend","_cancelRefEvent","send","_hasReceived","startTimeout","status","socket","push","topic","join_ref","_joinRef","updatePayload","Object","assign","receive","callback","_a","response","_this","_makeRef","_replyEventName","_cancelTimeout","_matchReceive","_on","setTimeout","trigger","_trigger","destroy","_off","clearTimeout","_ref","filter","h","forEach","default"],"sources":["C:\\Users\\deradoi\\udemy\\Crash Course - Build a Full Stack Web App\\today-i-learned\\node_modules\\@supabase\\realtime-js\\src\\lib\\push.ts"],"sourcesContent":["import { DEFAULT_TIMEOUT } from '../lib/constants'\nimport type RealtimeChannel from '../RealtimeChannel'\n\nexport default class Push {\n  sent: boolean = false\n  timeoutTimer: number | undefined = undefined\n  ref: string = ''\n  receivedResp: {\n    status: string\n    response: { [key: string]: any }\n  } | null = null\n  recHooks: {\n    status: string\n    callback: Function\n  }[] = []\n  refEvent: string | null = null\n  rateLimited: boolean = false\n\n  /**\n   * Initializes the Push\n   *\n   * @param channel The Channel\n   * @param event The event, for example `\"phx_join\"`\n   * @param payload The payload, for example `{user_id: 123}`\n   * @param timeout The push timeout in milliseconds\n   */\n  constructor(\n    public channel: RealtimeChannel,\n    public event: string,\n    public payload: { [key: string]: any } = {},\n    public timeout: number = DEFAULT_TIMEOUT\n  ) {}\n\n  resend(timeout: number) {\n    this.timeout = timeout\n    this._cancelRefEvent()\n    this.ref = ''\n    this.refEvent = null\n    this.receivedResp = null\n    this.sent = false\n    this.send()\n  }\n\n  send() {\n    if (this._hasReceived('timeout')) {\n      return\n    }\n    this.startTimeout()\n    this.sent = true\n    const status = this.channel.socket.push({\n      topic: this.channel.topic,\n      event: this.event,\n      payload: this.payload,\n      ref: this.ref,\n      join_ref: this.channel._joinRef(),\n    })\n    if (status === 'rate limited') {\n      this.rateLimited = true\n    }\n  }\n\n  updatePayload(payload: { [key: string]: any }): void {\n    this.payload = { ...this.payload, ...payload }\n  }\n\n  receive(status: string, callback: Function) {\n    if (this._hasReceived(status)) {\n      callback(this.receivedResp?.response)\n    }\n\n    this.recHooks.push({ status, callback })\n    return this\n  }\n\n  startTimeout() {\n    if (this.timeoutTimer) {\n      return\n    }\n    this.ref = this.channel.socket._makeRef()\n    this.refEvent = this.channel._replyEventName(this.ref)\n\n    const callback = (payload: any) => {\n      this._cancelRefEvent()\n      this._cancelTimeout()\n      this.receivedResp = payload\n      this._matchReceive(payload)\n    }\n\n    this.channel._on(this.refEvent, {}, callback)\n\n    this.timeoutTimer = <any>setTimeout(() => {\n      this.trigger('timeout', {})\n    }, this.timeout)\n  }\n\n  trigger(status: string, response: any) {\n    if (this.refEvent)\n      this.channel._trigger(this.refEvent, { status, response })\n  }\n\n  destroy() {\n    this._cancelRefEvent()\n    this._cancelTimeout()\n  }\n\n  private _cancelRefEvent() {\n    if (!this.refEvent) {\n      return\n    }\n\n    this.channel._off(this.refEvent, {})\n  }\n\n  private _cancelTimeout() {\n    clearTimeout(this.timeoutTimer)\n    this.timeoutTimer = undefined\n  }\n\n  private _matchReceive({\n    status,\n    response,\n  }: {\n    status: string\n    response: Function\n  }) {\n    this.recHooks\n      .filter((h) => h.status === status)\n      .forEach((h) => h.callback(response))\n  }\n\n  private _hasReceived(status: string) {\n    return this.receivedResp && this.receivedResp.status === status\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}